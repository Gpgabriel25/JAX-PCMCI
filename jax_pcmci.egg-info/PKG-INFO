Metadata-Version: 2.4
Name: jax-pcmci
Version: 0.1.0
Summary: High-performance causal discovery using PCMCI algorithms with JAX acceleration
Author: JAX-PCMCI Contributors
License: MIT
Project-URL: Homepage, https://github.com/your-org/jax-pcmci
Project-URL: Documentation, https://jax-pcmci.readthedocs.io
Project-URL: Repository, https://github.com/your-org/jax-pcmci
Keywords: causal-discovery,pcmci,jax,time-series,causality
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Scientific/Engineering :: Information Analysis
Requires-Python: >=3.9
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: jax>=0.4.20
Requires-Dist: jaxlib>=0.4.20
Requires-Dist: numpy>=1.24.0
Requires-Dist: scipy>=1.10.0
Requires-Dist: networkx>=3.0
Requires-Dist: matplotlib>=3.7.0
Requires-Dist: tqdm>=4.65.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0.0; extra == "dev"
Requires-Dist: black>=23.0.0; extra == "dev"
Requires-Dist: ruff>=0.1.0; extra == "dev"
Requires-Dist: mypy>=1.0.0; extra == "dev"
Requires-Dist: pre-commit>=3.0.0; extra == "dev"
Provides-Extra: docs
Requires-Dist: sphinx>=6.0.0; extra == "docs"
Requires-Dist: sphinx-rtd-theme>=1.2.0; extra == "docs"
Requires-Dist: sphinx-autodoc-typehints>=1.22.0; extra == "docs"
Requires-Dist: nbsphinx>=0.9.0; extra == "docs"
Requires-Dist: myst-parser>=1.0.0; extra == "docs"
Provides-Extra: gpu
Requires-Dist: jax[cuda12_pip]>=0.4.20; extra == "gpu"
Provides-Extra: tpu
Requires-Dist: jax[tpu]>=0.4.20; extra == "tpu"
Dynamic: license-file

# JAX-PCMCI

**High-Performance Causal Discovery from Time Series using JAX**

[![Python 3.9+](https://img.shields.io/badge/python-3.9+-blue.svg)](https://www.python.org/downloads/)
[![JAX](https://img.shields.io/badge/JAX-accelerated-green.svg)](https://github.com/google/jax)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

JAX-PCMCI is a library for causal discovery from time series data, implementing the PCMCI family of algorithms with GPU/TPU acceleration through JAX. It provides significant speedups over CPU-based implementations while maintaining scientific rigor.

## üöÄ Key Features

- **GPU/TPU Acceleration**: Leverages JAX for massive parallelization
- **PCMCI & PCMCI+**: Both lagged and contemporaneous causal discovery
- **Multiple Independence Tests**:
  - `ParCorr`: Partial correlation for linear dependencies
  - `CMIKnn`: k-NN conditional mutual information for nonlinear dependencies
  - `GPDCond`: Gaussian Process distance correlation for complex nonlinear relationships
- **Parallel Test Execution**: Vectorized batch testing with `vmap`/`pmap`
- **FDR Correction**: Built-in Benjamini-Hochberg and Bonferroni corrections
- **Publication-Ready Visualization**: Graph and time series plots

## üì¶ Installation

### Basic Installation (CPU)

```bash
pip install jax-pcmci
```

### With GPU Support (CUDA 12)

```bash
pip install jax-pcmci[gpu]
```

### With TPU Support

```bash
pip install jax-pcmci[tpu]
```

### From Source

```bash
git clone https://github.com/your-org/jax-pcmci.git
cd jax-pcmci
pip install -e ".[dev]"
```

## üèÉ Quick Start

### Basic PCMCI Analysis

```python
import jax.numpy as jnp
from jax_pcmci import PCMCI, ParCorr, DataHandler

# Generate sample data (T time points, N variables)
key = jax.random.PRNGKey(42)
T, N = 1000, 5
data = jax.random.normal(key, (T, N))

# Create data handler (automatically normalizes data)
datahandler = DataHandler(data, normalize=True)

# Run PCMCI with partial correlation test
pcmci = PCMCI(datahandler, cond_ind_test=ParCorr())
results = pcmci.run(tau_max=3, pc_alpha=0.05)

# View results
print(results.summary())

# Visualize causal graph
results.plot_graph()
```

### PCMCI+ for Contemporaneous Effects

```python
from jax_pcmci import PCMCIPlus, ParCorr, DataHandler

# PCMCI+ discovers both lagged AND contemporaneous causal links
pcmci_plus = PCMCIPlus(datahandler, cond_ind_test=ParCorr())
results = pcmci_plus.run(tau_max=3)

# Get contemporaneous links specifically
contemp_links = results.get_contemporaneous_links()
for src, tgt, stat, pval in contemp_links:
    print(f"X{src}(t) -> X{tgt}(t): stat={stat:.3f}, p={pval:.4f}")
```

### Nonlinear Causal Discovery

```python
from jax_pcmci import PCMCI, CMIKnn, DataHandler

# Use CMI-kNN for nonlinear relationships
test = CMIKnn(k=10, significance='permutation', n_permutations=200)
pcmci = PCMCI(datahandler, cond_ind_test=test)
results = pcmci.run(tau_max=3)
```

## üìä Available Independence Tests

### ParCorr (Partial Correlation)

Best for linear dependencies. Fastest test with analytical p-values.

```python
from jax_pcmci import ParCorr

test = ParCorr(
    significance='analytic',  # or 'permutation'
    alpha=0.05
)
```

### CMIKnn (Conditional Mutual Information with k-NN)

Captures nonlinear dependencies. Uses permutation testing.

```python
from jax_pcmci import CMIKnn

test = CMIKnn(
    k=10,                        # Number of neighbors
    significance='permutation',   # Required for accurate p-values
    n_permutations=500,
    metric='chebyshev'           # or 'euclidean'
)
```

### GPDCond (Gaussian Process Distance Correlation)

Advanced nonlinear test using GP regression residuals.

```python
from jax_pcmci import GPDCond

test = GPDCond(
    kernel='rbf',           # or 'matern32', 'matern52'
    length_scale=1.0,
    significance='permutation'
)
```

## ‚öôÔ∏è Configuration

### Device Selection

```python
from jax_pcmci import set_device, get_device_info

# Check available devices
info = get_device_info()
print(f"GPUs available: {info['gpu_count']}")
print(f"Default backend: {info['default_backend']}")

# Force specific device
set_device('gpu')   # Use GPU
set_device('tpu')   # Use TPU
set_device('cpu')   # Force CPU
set_device('auto')  # Auto-select best
```

### Global Configuration

```python
from jax_pcmci import PCMCIConfig

config = PCMCIConfig(
    precision='float64',       # 'float32' for speed, 'float64' for accuracy
    parallelization='auto',    # 'vmap', 'pmap', or 'sequential'
    random_seed=42,            # For reproducibility
    progress_bar=True,
    verbosity=1                # 0=silent, 1=normal, 2=verbose
)
config.apply()
```

## üìà Working with Results

### Accessing Causal Links

```python
results = pcmci.run(tau_max=3)

# All significant links
for src, tgt, tau, stat, pval in results.significant_links:
    print(f"X{src}(t-{tau}) -> X{tgt}(t)")

# Get parents of a specific variable
parents = results.get_parents(variable=0)

# Check specific link
is_causal = results.is_significant(source=1, target=0, lag=2)
```

### Visualization

```python
# Causal graph
fig = results.plot_graph(layout='circular', save_path='graph.png')

# Time series graph (shows temporal structure)
fig = results.plot_time_series_graph(save_path='ts_graph.png')

# Matrix heatmaps
fig = results.plot_matrix(matrix='val', save_path='values.png')
fig = results.plot_matrix(matrix='pval', save_path='pvalues.png')
```

### Export

```python
# To NetworkX
G = results.to_networkx()

# To dictionary (JSON-serializable)
data = results.to_dict()

# Save to file
import json
with open('results.json', 'w') as f:
    json.dump(data, f, indent=2)
```

## üî¨ Advanced Usage

### Custom Independence Test

```python
from jax_pcmci.independence_tests import CondIndTest
import jax.numpy as jnp

class MyCustomTest(CondIndTest):
    name = "MyTest"
    measure = "custom_measure"
    
    def compute_statistic(self, X, Y, Z=None):
        # Your JAX-compatible computation here
        # Must return a scalar JAX array
        pass
    
    def compute_pvalue(self, statistic, n_samples, n_conditions):
        # Compute p-value from statistic
        pass

# Use with PCMCI
pcmci = PCMCI(datahandler, cond_ind_test=MyCustomTest())
```

### Batch Processing for Large Datasets

```python
# For very large datasets, use batch MCI
results = pcmci.run_batch_mci(tau_max=5)
```

### Memory-Efficient Mode

```python
config = PCMCIConfig(
    memory_efficient=True,  # Trades speed for memory
    batch_size=100          # Process tests in batches
)
config.apply()
```

## üìö Algorithm Details

### PCMCI

PCMCI (Peter and Clark Momentary Conditional Independence) is a two-phase algorithm:

1. **PC Phase**: Iteratively removes spurious parent candidates using conditional independence tests with increasing conditioning set sizes.

2. **MCI Phase**: Tests remaining links using Momentary Conditional Independence, conditioning on the parents of both source and target.

### PCMCI+

PCMCI+ extends PCMCI to handle contemporaneous (œÑ=0) causal links:

1. **Skeleton Discovery**: Finds undirected edges including contemporaneous
2. **Orientation**: Uses time order and v-structure rules to orient edges
3. **MCI Testing**: Final tests with full conditioning sets

## üß™ Comparison with Tigramite

| Feature | JAX-PCMCI | Tigramite |
|---------|-----------|-----------|
| GPU/TPU Support | ‚úÖ Native | ‚ùå CPU only |
| Parallelization | ‚úÖ vmap/pmap | ‚ö†Ô∏è Limited |
| JIT Compilation | ‚úÖ Full | ‚ùå No |
| Independence Tests | ParCorr, CMI, GPDC | Many |
| Speed (GPU) | 10-100x faster | Baseline |

## üìñ References

1. Runge, J. et al. (2019). "Detecting and quantifying causal associations in large nonlinear time series datasets". Science Advances, 5(11), eaau4996.

2. Runge, J. (2020). "Discovering contemporaneous and lagged causal relations in autocorrelated nonlinear time series datasets". UAI 2020.

3. Spirtes, P., Glymour, C., & Scheines, R. (2000). "Causation, prediction, and search". MIT press.

## üìÑ License

MIT License - see [LICENSE](LICENSE) for details.

## ü§ù Contributing

Contributions are welcome! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

## üìß Contact

For questions or issues, please open a GitHub issue or contact the maintainers.
